from abstract_simplicial_complex import Point, Simplex, ASC
from copy import deepcopy
from itertools import combinations

import numpy as np


# Number of cutoffs at which diameter thresholds are chosen (ignored if custom list is specified for generate_filtration)
DEFAULT_NUM_SAMPLE_DIAMETERS = 20


# Member variables:
#  N: number of points
#  max_dimension: upper bound on dimension of the ASCs to be computed
#  unordered_points: (non-sorted) set of points
#  ordered_points: (sorted) list of points
#  distance_ordered_pairs: (sorted) list of (distance, pairs) where pairs is an ordered list of indices corresponding to 1-simplices
#  selected_thresholds: the diameters chosen in generating the filtration
#  asc_sequence: the sequence of ASC generated by filtration
#  index_sequence: a sequence of (list of (simplex indices) for each dimension) generated by the filtration
#  all_simplices: list of (list of simplices) for each dimension
#  simplex_indices: list of (map from simplex to ordered index) for each dimension
#  coface_adjlist: list of (list of (list of simplices for which this simplex is a face) for each simplex) for each dimension
#  num_faces_remaining: list of (list of integers representing the number of faces not yet filled in for each simplex) for each dimension
class Filtration:
    # Parameters
    #  points: set of Point
    #  max_dimension: positive integer for highest dimension of ASCs to consider
    def __init__(self, points, max_dimension):
        self.unordered_points = points
        self.N = len(points)
        self.max_dimension = max_dimension
        self.order_points()
        self.compute_pairwise_distances()
        self.generate_simplex_spaces()
        self.initialize_simplex_graph()
    
    # Sort the points according to their canonical order and save this ordering as indices
    def order_points(self):
        self.ordered_points = sorted(list(self.unordered_points))
        self.point_indices = {}
        for i,p in enumerate(self.ordered_points):
            self.point_indices[p] = i
    
    # Convert the list of ordered points into a human-readable format, for debugging
    def stringify_ordered_points(self):
        return '{' + ',\n'.join([str(i) + ': ' + str(p) for i,p in enumerate(self.ordered_points)]) + '}'
    
    # Prints the point indices, distance matrix, and edges added at each diameter.
    def print_metadata(self):
        print("Ordered points: ")
        print(self.stringify_ordered_points())
        print()
        print("Distance matrix: ")
        print(self.distance_matrix)
        print()
        print("Pairs of indices by ordered distance: ")
        print("{" + ";\n".join([str(dp) for dp in self.distance_ordered_pairs]) + "}")
        print("\n")
    
    # Prints the ASC sequence in this filtration (only to be called after generate_filtration)
    def print_filtration(self):
        for diameter,asc in zip([0] + self.selected_diameters, self.asc_sequence):
            print("Diameter = " + str(diameter))
            print("ASC: ")
            print(asc)
            print("\n")
    
    # Store a cache for efficient retrieval of distances computed between each pair of points,
    # as well as an ordered list of distances.
    def compute_pairwise_distances(self):
        self.distance_matrix = np.zeros((self.N, self.N))
        distance_ordered_pairs = {}
        for i in range(self.N):
            for j in range(i + 1, self.N):
                # Calculate the distance between two points and update our matrix
                pi = self.ordered_points[i]
                pj = self.ordered_points[j]
                distance = pi.distance_to(pj)
                self.distance_matrix[i][j] = self.distance_matrix[j][i] = distance
                # Add this distance to the dictionary from distance to list of index pairs
                if distance not in distance_ordered_pairs:  # Note: exact floating-point comparisons
                    distance_ordered_pairs[distance] = []
                distance_ordered_pairs[distance].append((i,j))
        self.distance_ordered_pairs = sorted(list(distance_ordered_pairs.items()))  # convert from dict to (sorted)) list
    
    # Create and store all simplices up to the maximum order, with ordered index in each dimension.
    def generate_simplex_spaces(self):
        # Initialize an empty list for each dimension
        self.all_simplices = [[] for k in range(self.max_dimension + 1)]
        assert(self.ordered_points == sorted(self.ordered_points))
        # Populate each list of simplices, and sort the list
        for k in range(1, self.max_dimension + 1):  # for each dimension (above 0)
            for subset in combinations(self.ordered_points, k+1):
                self.all_simplices[k].append(Simplex(points=set(subset)))
            self.all_simplices[k].sort()
        # Store the inverse mapping from each simplex to its ordered index.
        self.simplex_indices = [{} for k in range(self.max_dimension + 1)]
        for k in range(self.max_dimension + 1):
            for i, sim in enumerate(self.all_simplices[k]):
                self.simplex_indices[k][sim] = i
    
    # Populate an adjacency list representation for the "subset" property, and initialize the number of faces to be filled for each simplex.
    def initialize_simplex_graph(self, verbose=False):
        # 3-dimensional array of (dimension, simplex, cofaces)
        self.coface_adjlist = [[[] for i in range(len(self.simplex_indices[k]))] for k in range(self.max_dimension)]
        for k in range(self.max_dimension):  # from 0 to (max_dimension - 1)
            for i, sim in enumerate(self.all_simplices[k]):
                for p in self.ordered_points:  # for each point
                    # Check that it's not already in this simplex
                    if p in sim.points:
                        continue
                    coface = Simplex(points=(sim.points | {p}))
                    if verbose:
                        print("sim = " + str(sim))
                        print("coface = " + str(coface))
                    self.coface_adjlist[k][i].append(self.simplex_indices[k+1][coface])
        if verbose:
            print("coface_adjlist:")
            print(self.coface_adjlist)
        # 2-dimensional array of (dimension, simplex)
        self.num_faces_remaining = [[k+1 for i in range(len(self.simplex_indices[k]))] for k in range(self.max_dimension + 1)]
    
    # Includes all 0-dimensional simplices
    def create_zeroth_asc(self):
        new_asc = ASC()
        for p in self.ordered_points:
            new_asc.add_simplex(Simplex(points={p}))
        return new_asc
    
    # 2-dimensional array for (dimension, simplex index)
    def create_zeroth_indices(self):
        # Initialie 2d array
        dimension_indices = [[] for k in range(self.max_dimension + 1)]
        # Populate all indices from the 0-th dimension
        dimension_indices[0] = [i for i in range(len(self.ordered_points))]
        return dimension_indices
    
    # Chooses up to num_diameters from distance_ordered_pairs at a roughly uniform number of edges per cutoff threshold.
    def uniformly_sample_diameters(self, num_diameters, minimum_diameter=0):
        # Estimate the number of edges per cutoff.
        assert(num_diameters >= 1)
        total_num_edges = sum([len(edges) for diameter, edges in self.distance_ordered_pairs])
        approx_edges_per_interval = total_num_edges / (num_diameters - 1)
        # Select diameters from a sorted list at uniform gaps.
        selected_diameters = [minimum_diameter]
        edge_count = 0
        for diameter, edges in self.distance_ordered_pairs:
            edge_count += len(edges)
            if edge_count >= approx_edges_per_interval:
                edge_count = 0
                selected_diameters.append(diameter)
        return selected_diameters
    
    # Every subcomplex (ASC) with simplices up to the max_diameter will be stored in this object (self.asc_sequence)
    # Either a fixed number of diameters can be selected using the uniformly_sample_diameters method, or a custom list can be passed in
    # TODO(optimization): instead of storing the original ASC, store an ASC of the Point indices (without copying names, coordinates)
    def generate_filtration(self, selected_diameters=None, verbosity=0):
        # By default, pick 10 diameters to uniformly partition the sorted list of edges.
        if selected_diameters is None:
            selected_diameters = self.uniformly_sample_diameters(DEFAULT_NUM_SAMPLE_DIAMETERS)
        self.selected_diameters = selected_diameters  # Store this value as needed for print_filtration
        # Special case: Start with all points in zeroth ASC
        self.asc_sequence = [self.create_zeroth_asc()]
        self.index_sequence = [self.create_zeroth_indices()]
        ## self.selected_diameter_indices = range(len(self.distance_ordered_pairs))  # TODO(sampling)
        ## self.selected_diameters = [self.distance_ordered_pairs[i][0] for i in self.selected_diameter_indices]
        i = 0  # list index in distance_ordered_pairs
        # For each selected diameter
        for diameter in selected_diameters:
            new_asc = self.asc_sequence[-1].deepcopy()
            # Gather a set of 1-simplices with distance no greater than current cutoff
            edge_indices = []
            while i < len(self.distance_ordered_pairs) and self.distance_ordered_pairs[i][0] <= diameter:
                edge_indices.extend(self.distance_ordered_pairs[i][1])
                i += 1
            if verbosity >= 1:
                print()
                print("diameter cutoff threshold = " + str(diameter))
                if verbosity >= 2:
                    print("edge indices = " + str(edge_indices))
                if verbosity >= 3:
                    print("previous asc: ")
                    print(new_asc)
            # Initialize queue of simplices
            new_simplices_queue = []
            for i,j in edge_indices:
                new_simplices_queue.append(Simplex(points={self.ordered_points[i], self.ordered_points[j]}))
            # Add simplices in order of dimension, k (breadth-first search expansion)
            while new_simplices_queue:
                # Initialize the list of simplices of higher dimension, k+1
                next_simplices_queue = []
                for new_face in new_simplices_queue:
                    k = new_face.dimension()
                    # Birth: dimension = k
                    new_asc.add_simplex(new_face.copy())
                    if verbosity >= 2:
                        print("add " + str(new_face))
                    # Stop expanding further if we've reached the maximum dimension
                    if k == self.max_dimension:
                        continue
                    # Otherwise, check each coface of this simplex
                    face_index = self.simplex_indices[k][new_face]
                    for sim_index in self.coface_adjlist[k][face_index]:
                        # Decrease the number of faces that remain to be filled in
                        self.num_faces_remaining[k+1][sim_index] -= 1
                        # If all faces have been filled in, then add it to the queue
                        if self.num_faces_remaining[k+1][sim_index] == 0:
                            next_simplices_queue.append(self.all_simplices[k+1][sim_index])
                new_simplices_queue = next_simplices_queue
            self.asc_sequence.append(new_asc)
        if verbosity >= 1:
            print("\n")
