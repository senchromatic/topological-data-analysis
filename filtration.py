from abstract_simplicial_complex import Point, Simplex, ASC

from copy import deepcopy
import numpy as np


# Members:
#  N: number of points
#  max_dimension: upper bound on dimension of the ASCs to be computed
#  unordered_points: (non-sorted) set of points
#  ordered_points: (sorted) list of points
#  distance_ordered_pairs: (sorted) list of (distance, pairs) where pairs is an ordered list of indices corresponding to 1-simplices
#  selected_thresholds: the diameters chosen in generating the filtration
#  asc_sequence: the sequence of ASC generated by filtration
class Filtration:
    # Parameters
    #  points: set of Point
    #  max_dimension: positive integer for highest dimension of ASCs to consider
    def __init__(self, points, max_dimension):
        self.unordered_points = points
        self.N = len(points)
        self.max_dimension = max_dimension
        self.order_points()
        self.compute_pairwise_distances()
    
    # Sort the points according to their canonical order and save this ordering as indices
    def order_points(self):
        self.ordered_points = sorted(list(self.unordered_points))
        self.point_indices = {}
        for i,p in enumerate(self.ordered_points):
            self.point_indices[p] = i
    
    # Convert the list of ordered points into a human-readable format, for debugging
    def stringify_ordered_points(self):
        return '{' + ',\n'.join([str(i) + ': ' + str(p) for i,p in enumerate(self.ordered_points)]) + '}'
    
    # Prints the point labels, distance matrix, and ASC sequence in this filtration
    def print_filtration(self, verbosity=0):
        print("Ordered points: ")
        print(self.stringify_ordered_points())
        print()
        print("Distance matrix: ")
        print(self.distance_matrix)
        print()
        print("Pairs of indices by ordered distance: ")
        print("{" + ";\n".join([str(dp) for dp in self.distance_ordered_pairs]) + "}")
        print("\n")
        
        self.generate_filtration(verbosity)
        for diameter,asc in zip([0] + self.selected_diameters, self.asc_sequence):
            print("Diameter = " + str(diameter))
            print("ASC: ")
            print(asc)
            print("\n")
    
    # Store a cache for efficient retrieval of distances computed between each pair of points,
    # as well as an ordered list of distances.
    def compute_pairwise_distances(self):
        self.distance_matrix = np.zeros((self.N, self.N))
        distance_ordered_pairs = {}
        for i in range(self.N):
            for j in range(i + 1, self.N):
                # Calculate the distance between two points and update our matrix
                pi = self.ordered_points[i]
                pj = self.ordered_points[j]
                distance = pi.distance_to(pj)
                self.distance_matrix[i][j] = self.distance_matrix[j][i] = distance
                # Add this distance to the dictionary from distance to list of index pairs
                if distance not in distance_ordered_pairs:  # Note: exact floating-point comparisons
                    distance_ordered_pairs[distance] = []
                distance_ordered_pairs[distance].append((i,j))
        self.distance_ordered_pairs = sorted(list(distance_ordered_pairs.items()))  # convert from dict to (sorted)) list
    
    # Includes all 0-dimensional simplices
    def create_zeroth_asc(self):
        new_asc = ASC()
        for p in self.ordered_points:
            new_asc.add_simplex(Simplex(points={p}))
        return new_asc
    
    # Every ASC will be stored in this object (self.asc_sequence)
    # TODO(sampling): add other threshold sampling methods, if we don't want to include all distances as thresholds
    # TODO(optimization): instead of storing the original ASC, store an ASC of the Point indices (without copying names, coordinates)
    def generate_filtration(self, verbosity=0):
        # Special case: Start with all points in zeroth ASC
        self.asc_sequence = [self.create_zeroth_asc()]
        self.selected_diameter_indices = range(len(self.distance_ordered_pairs))  # TODO(sampling)
        self.selected_diameters = [self.distance_ordered_pairs[i][0] for i in self.selected_diameter_indices]
        # For each selected diameter index
        for i in self.selected_diameter_indices:
            new_asc = self.asc_sequence[-1].deepcopy()
            # Get the diameter and set of 1-simplices
            # TODO: make use of diameter?
            diameter, edge_indices = self.distance_ordered_pairs[i]
            if verbosity >= 1:
                print()
                print("diam = " + str(diameter))
                if verbosity >= 2:
                    print("edge indices = " + str(edge_indices))
                if verbosity >= 3:
                    print("previous asc: ")
                    print(new_asc)
            # Initialize queue of simplices
            new_simplices_queue = []
            for i,j in edge_indices:
                new_simplices_queue.append(Simplex(points={self.ordered_points[i], self.ordered_points[j]}))
            # Add simplices in order of dimension, k (breadth-first search expansion)
            while new_simplices_queue:
                # Initialize the list of simplices of higher dimension, k+1
                next_simplices_queue = []
                for new_face in new_simplices_queue:
                    # Birth: dimension = k
                    new_asc.add_simplex(new_face.copy())
                    if verbosity >= 2:
                        print("add " + str(new_face))
                    # Stop expanding further if we've reached the maximum dimension
                    if new_face.dimension == self.max_dimension:
                        continue
                    # Otherwise, check if this simplex is a face for any simplex of dimension k+1
                    for p in self.ordered_points:
                        if p in new_face.points:
                            continue
                        # Create the k+1 simplex
                        new_sim = new_face.copy()
                        new_sim.add_point(p)
                        if verbosity >= 3:
                            print("new sim: " + str(new_sim))
                        # TODO: modularize this into a function
                        # Delete each other point and check whether the other faces are in the ASC
                        full_simplex = True
                        for q in new_sim.points - {p}:
                            other_face = new_sim.copy()
                            other_face.remove_point(q)
                            if other_face not in new_asc.simplices:
                                full_simplex = False
                                break
                        if full_simplex:
                            next_simplices_queue.append(new_sim)
                new_simplices_queue = next_simplices_queue
            self.asc_sequence.append(new_asc)
