from abstract_simplicial_complex import Point, Simplex, Boundary, ASC
from copy import deepcopy
from itertools import combinations
from math import pow
from sparse_matrix import Z2SparseSquareMatrix
from z2array import z2array_zeros, z2rank

import numpy as np


# Number of cutoffs at which diameter thresholds are chosen (ignored if custom list is specified for generate_filtration)
DEFAULT_ARITHMETIC_SAMPLE_DIAMETERS = 20
DEFAULT_GEOMETRIC_SAMPLE_DIAMETERS = 100
USE_GEOMETRIC_SAMPLING = True  # False: approximately equal number of edges per diameter, True: diameters form a roughly geometric sequence


# Member variables:
#  N: number of points
#  max_dimension: upper bound on dimension of the ASCs to be computed
#  unordered_points: (non-sorted) set of points
#  ordered_points: (sorted) list of points
#  distance_ordered_pairs: (sorted) list of (distance, pairs) where pairs is an ordered list of indices corresponding to 1-simplices
#  selected_thresholds: the diameters chosen in generating the filtration
#  asc_sequence: the sequence of ASC generated by filtration
#  index_sequence: a sequence of (list of (simplex indices) for each dimension) generated by the filtration
#  all_simplices: list of (list of simplices) for each dimension
#  simplex_indices: list of (map from simplex to ordered index) for each dimension
#  coface_adjlist: list of (list of (list of simplices for which this simplex is a face) for each simplex) for each dimension
#  num_faces_remaining: list of (list of integers representing the number of faces not yet filled in for each simplex) for each dimension
#  boundary_matrix: boundary (sparse square Z_2) matrix of the filtered ASC, constructed and reduced in generate_filtration
#  ordered_simplices: list of simplices (in order of being added to the filtration), used for computing homologies
#  ordered_diameters: list of diameters (one for each simplex added), used for plotting persistence diagrams
#  ordered_dimensions: list of dimensions (for for each simplex added), used for plotting persistence diagrams 
class Filtration:
    # Parameters
    #  points: set of Point
    #  max_dimension: positive integer for highest dimension of ASCs to consider
    def __init__(self, points, max_dimension):
        self.unordered_points = points
        self.N = len(points)
        self.max_dimension = max_dimension
        self.order_points()
        self.compute_pairwise_distances()
        self.generate_simplex_spaces()
        self.initialize_simplex_graph()
    
    # Sort the points according to their canonical order and save this ordering as indices
    def order_points(self):
        self.ordered_points = sorted(list(self.unordered_points))
        self.point_indices = {}
        for i,p in enumerate(self.ordered_points):
            self.point_indices[p] = i
    
    # Convert the list of ordered points into a human-readable format, for debugging
    def stringify_ordered_points(self):
        return '{' + ',\n'.join([str(i) + ': ' + str(p) for i,p in enumerate(self.ordered_points)]) + '}'
    
    # Prints the point indices, distance matrix, and edges added at each diameter.
    def print_metadata(self):
        print("Ordered points: ")
        print(self.stringify_ordered_points())
        print()
        print("Distance matrix: ")
        print(self.distance_matrix)
        print()
        print("Pairs of indices by ordered distance: ")
        print("{" + ";\n".join([str(dp) for dp in self.distance_ordered_pairs]) + "}")
        print("\n")
    
    # Prints the ASC sequence in this filtration (only to be called after generate_filtration)
    def print_filtration(self):
        for diameter,asc in zip([0] + self.selected_diameters, self.asc_sequence):
            print("Diameter = " + str(diameter))
            print("ASC: ")
            print(asc)
            print("\n")
    
    # Store a cache for efficient retrieval of distances computed between each pair of points,
    # as well as an ordered list of distances.
    def compute_pairwise_distances(self):
        self.distance_matrix = np.zeros((self.N, self.N))
        distance_ordered_pairs = {}
        for i in range(self.N):
            for j in range(i + 1, self.N):
                # Calculate the distance between two points and update our matrix
                pi = self.ordered_points[i]
                pj = self.ordered_points[j]
                distance = pi.distance_to(pj)
                self.distance_matrix[i][j] = self.distance_matrix[j][i] = distance
                # Add this distance to the dictionary from distance to list of index pairs
                if distance not in distance_ordered_pairs:  # Note: exact floating-point comparisons
                    distance_ordered_pairs[distance] = []
                distance_ordered_pairs[distance].append((i,j))
        self.distance_ordered_pairs = sorted(list(distance_ordered_pairs.items()))  # convert from dict to (sorted)) list
    
    # Create and store all simplices up to the maximum order, with ordered index in each dimension.
    def generate_simplex_spaces(self):
        # Initialize an empty list for each dimension
        self.all_simplices = [[] for k in range(self.max_dimension + 1)]
        assert(self.ordered_points == sorted(self.ordered_points))
        # Populate each list of simplices, and sort the list
        for k in range(self.max_dimension + 1):  # for each dimension (including 0)
            for subset in combinations(self.ordered_points, k+1):
                self.all_simplices[k].append(Simplex(points=set(subset)))
            self.all_simplices[k].sort()
        # Store the inverse mapping from each simplex to its ordered index.
        self.simplex_indices = [{} for k in range(self.max_dimension + 1)]
        for k in range(self.max_dimension + 1):
            for i, sim in enumerate(self.all_simplices[k]):
                self.simplex_indices[k][sim] = i
    
    # Populate an adjacency list representation for the "subset" property, and initialize the number of faces to be filled for each simplex.
    def initialize_simplex_graph(self, verbose=False):
        # 3-dimensional array of (dimension, simplex, cofaces)
        self.coface_adjlist = [[[] for i in range(len(self.simplex_indices[k]))] for k in range(self.max_dimension)]
        for k in range(self.max_dimension):  # from 0 to (max_dimension - 1)
            for i, sim in enumerate(self.all_simplices[k]):
                for p in self.ordered_points:  # for each point
                    # Check that it's not already in this simplex
                    if p in sim.points:
                        continue
                    coface = Simplex(points=(sim.points | {p}))
                    if verbose:
                        print("sim = " + str(sim))
                        print("coface = " + str(coface))
                    self.coface_adjlist[k][i].append(self.simplex_indices[k+1][coface])
        if verbose:
            print("coface_adjlist:")
            print(self.coface_adjlist)
        # 2-dimensional array of (dimension, simplex)
        self.num_faces_remaining = [[k+1 for i in range(len(self.simplex_indices[k]))] for k in range(self.max_dimension + 1)]
    
    # Includes all 0-dimensional simplices
    def create_zeroth_asc(self):
        new_asc = ASC()
        for p in self.ordered_points:
            new_asc.add_simplex(Simplex(points={p}))
        return new_asc
    
    # 2-dimensional array for (dimension, simplex index)
    def create_zeroth_indices(self):
        # Initialize 2d array
        dimension_indices = [[] for k in range(self.max_dimension + 1)]
        # Populate all indices from the 0-th dimension
        dimension_indices[0] = [i for i in range(len(self.ordered_points))]
        return dimension_indices
    
    # Chooses up to num_diameters from distance_ordered_pairs at a roughly uniform number of edges per cutoff threshold.
    # Diameters above the maximum are excluded.
    def uniformly_sample_diameters(self, num_diameters, minimum_diameter=0, maximum_diameter=None):
        # Estimate the number of edges per cutoff.
        assert(num_diameters >= 1)
        total_num_edges = sum([len(edges) for diameter, edges in self.distance_ordered_pairs])
        approx_edges_per_interval = total_num_edges / (num_diameters - 1)
        # Select diameters from a sorted list at uniform gaps.
        selected_diameters = [minimum_diameter]
        edge_count = 0
        for diameter, edges in self.distance_ordered_pairs:
            if diameter > maximum_diameter:
                break
            edge_count += len(edges)
            if edge_count >= approx_edges_per_interval:
                edge_count = 0
                selected_diameters.append(diameter)
        return selected_diameters
    
    # Choose up to num_diameters from epsilon_diameter to maximum_diameter in (approximate) geometric sequence.
    def geometric_sequence_diameters(self, num_diameters, minimum_diameter=0, epsilon_diameter=0.01, maximum_diameter=0.99):
        assert(num_diameters >= 1)
        # 0 <= min < epsilon < max
        assert(0 <= minimum_diameter)
        assert(minimum_diameter < epsilon_diameter)
        assert(epsilon_diameter < maximum_diameter)
        # Prepare geometric sequence
        selected_diameters = [minimum_diameter]
        range_ratio = maximum_diameter / epsilon_diameter
        step_ratio = pow(range_ratio, 1.0 / num_diameters)
        cutoff_threshold = epsilon_diameter
        # Selected diameters at roughly geometric gaps
        for diameter, _ in self.distance_ordered_pairs:
            if diameter > maximum_diameter:
                break
            if diameter > cutoff_threshold:
                selected_diameters.append(diameter)
                cutoff_threshold *= step_ratio
        return selected_diameters
    
    # Every subcomplex (ASC) with simplices up to the max_diameter will be stored in this object (self.asc_sequence),
    # and a sparse boundary matrix (with all simplices in the filtered ASC) will be generated
    # Either a fixed number of diameters can be selected using the uniformly_sample_diameters method, or a custom list can be passed in
    # If maximum_diameter is specified, the filtration will not consider diameters greater than the argument value
    # TODO(optimization): instead of storing the original ASC, store an ASC of the Point indices (without copying names, coordinates)
    def generate_filtration(self, selected_diameters=None, epsilon_diameter=0.01, maximum_diameter=0.99, verbosity=0):
        # By default, pick 10 diameters to uniformly partition the sorted list of edges.
        if selected_diameters is None:
            if USE_GEOMETRIC_SAMPLING:
                selected_diameters = self.geometric_sequence_diameters(DEFAULT_GEOMETRIC_SAMPLE_DIAMETERS, epsilon_diameter=epsilon_diameter, maximum_diameter=maximum_diameter)
            else:
                selected_diameters = self.uniformly_sample_diameters(DEFAULT_ARITHMETIC_SAMPLE_DIAMETERS, maximum_diameter=maximum_diameter)
        self.selected_diameters = selected_diameters  # Store this value as needed for print_filtration
        # Special case: Start with all points in zeroth ASC
        self.asc_sequence = [self.create_zeroth_asc()]
        self.index_sequence = [self.create_zeroth_indices()]
        ## self.selected_diameter_indices = range(len(self.distance_ordered_pairs))  # TODO(sampling)
        ## self.selected_diameters = [self.distance_ordered_pairs[i][0] for i in self.selected_diameter_indices]
        # Initialize a 1-dimensional dictionary from simplex to order in which it was added
        # (note that unlike simplex_indices, this is a flat list for all simplices, as necessary for the boundary matrix)
        simplex_ordering = {}
        # Initialize the inverse map of simplex_ordering
        self.ordered_simplices = []
        # List of ordering to diameters, in general containing duplicates; the values of simplex_ordering are the indices of ordered_diameters
        self.ordered_diameters = []
        # List of ordering to dimensions, in general containing duplicates; the values of simplex_ordering are the indices of ordered_dimensions
        self.ordered_dimensions = []
        # Add all 0-dimension simplices to simplex_ordering, ordered_simplices, ordered_diameters, and ordered_dimensions
        for p in self.ordered_points:
            simplex_ordering[Simplex({p})] = len(simplex_ordering)
            self.ordered_simplices.append(Simplex({p}))
            self.ordered_diameters.append(0)
            self.ordered_dimensions.append(0)
        i = 0  # list index in distance_ordered_pairs
        # For each selected diameter
        for diameter in selected_diameters:
            new_asc = self.asc_sequence[-1].deepcopy()
            # Gather a set of 1-simplices with distance no greater than current cutoff
            edge_indices = []
            while i < len(self.distance_ordered_pairs) and self.distance_ordered_pairs[i][0] <= diameter:
                edge_indices.extend(self.distance_ordered_pairs[i][1])
                i += 1
            if verbosity >= 1:
                print()
                print("diameter cutoff threshold = " + str(diameter))
                if verbosity >= 2:
                    print("edge indices = " + str(edge_indices))
                if verbosity >= 3:
                    print("previous asc: ")
                    print(new_asc)
            # Initialize queue of simplices
            new_simplices_queue = []
            for ei,ej in edge_indices:
                new_simplices_queue.append(Simplex(points={self.ordered_points[ei], self.ordered_points[ej]}))
            # Add simplices in order of dimension, k (breadth-first search expansion)
            while new_simplices_queue:
                # Initialize the list of simplices of higher dimension, k+1
                next_simplices_queue = []
                for new_face in new_simplices_queue:
                    simplex_ordering[new_face] = len(simplex_ordering)
                    self.ordered_simplices.append(new_face)
                    self.ordered_diameters.append(diameter)
                    k = new_face.dimension()
                    self.ordered_dimensions.append(k)
                    # Birth: dimension = k
                    new_asc.add_simplex(new_face.copy())
                    if verbosity >= 2:
                        print("add " + str(new_face) + " with index " + str(simplex_ordering[new_face]))
                    # Stop expanding further if we've reached the maximum dimension
                    if k == self.max_dimension:
                        continue
                    # Otherwise, check each coface of this simplex
                    face_index = self.simplex_indices[k][new_face]
                    for sim_index in self.coface_adjlist[k][face_index]:
                        # Decrease the number of faces that remain to be filled in
                        self.num_faces_remaining[k+1][sim_index] -= 1
                        # If all faces have been filled in, then add it to the queue
                        if self.num_faces_remaining[k+1][sim_index] == 0:
                            next_simplices_queue.append(self.all_simplices[k+1][sim_index])
                new_simplices_queue = next_simplices_queue
            self.asc_sequence.append(new_asc)
        # Create the boundary matrix for the filtered ASC
        M = len(simplex_ordering)
        self.boundary_matrix = Z2SparseSquareMatrix(M)
        for face, r in simplex_ordering.items():  # r: row number in the boundary matrix
            k = face.dimension()
            face_index = self.simplex_indices[k][face]
            # No cofaces for simplices of the maximum dimension
            if k == self.max_dimension:
                continue
            # Add an entry for each coface of this face
            for sim_index in self.coface_adjlist[k][face_index]:
                coface = self.all_simplices[k+1][sim_index]
                # Coface may not be included if it's beyond the max diameter
                # TODO: Find a way of excluding large cofaces upfront, rather than using simplex_ordering
                if coface not in simplex_ordering:
                    continue
                c = simplex_ordering[coface]  # c : column number in the boundary matrix
                self.boundary_matrix.flip_entry(c, r)
        if verbosity >= 1:
            print("\n")
        if verbosity >= 2:
            print("Non-reduced (sparse) boundary matrix")
            print(self.boundary_matrix)
        self.boundary_matrix.column_reduction(verbose=(verbosity >= 2))
    
    # Returns a dict of column index (in the sparse matrix) to (non-trivial) homologies
    # Each homology is internally represented as a Boundary object
    def extract_homologies(self):
        homologies = dict()
        cycle_indices = self.boundary_matrix.find_all_cycle_indices()
        for ci in cycle_indices:
            sim_indices = self.boundary_matrix.get_cycle_at_index(ci)
            # Skip trivial homologies
            if not sim_indices:
                continue
            # Extract the simplices in this cycle based on the indices
            cycle_simplices = [self.ordered_simplices[cj] for cj in sim_indices.entries]
            k = cycle_simplices[0].dimension()
            # Obtain B_k = Im(del_{k+1})
            diameter_index = self.ordered_dimensions[ci]
            birth_asc = self.asc_sequence[diameter_index]
            birth_asc.compute_boundary(k+1)
            image_space = birth_asc.extract_boundary_image(k+1)
            ordered_chains = sorted(image_space.chains)
            # Number the k-simplices
            simplex_numbering = dict()
            for sim in cycle_simplices:
                simplex_numbering[sim] = len(simplex_numbering)
            for boundary in ordered_chains:
                for sim in boundary.simplices:
                    if sim in simplex_numbering:
                        continue
                    simplex_numbering[sim] = len(simplex_numbering)
            num_rows = len(ordered_chains)
            num_cols = len(simplex_numbering)
            # Construct a matrix for the image space
            # The (r,c) entries of each r-th row in the matrix indicate whether this chain contains the c-th simplex.
            image_space_matrix = z2array_zeros((num_rows+1, num_cols))
            for r, chains in enumerate(ordered_chains):
                for sim in chains.simplices:
                    image_space_matrix[r, simplex_numbering[sim]] = 1
            image_space_rank = z2rank(image_space_matrix, nullspace=False)
            # Adjoin a new row for the cycle
            for sim in cycle_simplices:
                image_space_matrix[num_rows, simplex_numbering[sim]] = 1
            # Skip bounded cycles
            if image_space_rank == z2rank(image_space_matrix, nullspace=False):
                continue
            homology = Boundary()
            for sim in cycle_simplices:
                homology.xor(sim)  # Each sim should only be added once
            homologies[ci] = homology
        return homologies